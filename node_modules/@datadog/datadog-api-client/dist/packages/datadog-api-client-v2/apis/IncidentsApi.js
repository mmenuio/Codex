"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IncidentsApi = exports.IncidentsApiResponseProcessor = exports.IncidentsApiRequestFactory = void 0;
const baseapi_1 = require("../../datadog-api-client-common/baseapi");
const configuration_1 = require("../../datadog-api-client-common/configuration");
const http_1 = require("../../datadog-api-client-common/http/http");
const logger_1 = require("../../../logger");
const ObjectSerializer_1 = require("../models/ObjectSerializer");
const exception_1 = require("../../datadog-api-client-common/exception");
class IncidentsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createIncident(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'createIncident'");
            if (!_config.unstableOperations["v2.createIncident"]) {
                throw new Error("Unstable operation 'createIncident' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.createIncident").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createIncidentIntegration(incidentId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'createIncidentIntegration'");
            if (!_config.unstableOperations["v2.createIncidentIntegration"]) {
                throw new Error("Unstable operation 'createIncidentIntegration' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "createIncidentIntegration");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createIncidentIntegration");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/relationships/integrations".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.createIncidentIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentIntegrationMetadataCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteIncident(incidentId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'deleteIncident'");
            if (!_config.unstableOperations["v2.deleteIncident"]) {
                throw new Error("Unstable operation 'deleteIncident' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "deleteIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.deleteIncident").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteIncidentIntegration(incidentId, integrationMetadataId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'deleteIncidentIntegration'");
            if (!_config.unstableOperations["v2.deleteIncidentIntegration"]) {
                throw new Error("Unstable operation 'deleteIncidentIntegration' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "deleteIncidentIntegration");
            }
            // verify required parameter 'integrationMetadataId' is not null or undefined
            if (integrationMetadataId === null || integrationMetadataId === undefined) {
                throw new baseapi_1.RequiredError("integrationMetadataId", "deleteIncidentIntegration");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/relationships/integrations/{integration_metadata_id}"
                .replace("{incident_id}", encodeURIComponent(String(incidentId)))
                .replace("{integration_metadata_id}", encodeURIComponent(String(integrationMetadataId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.deleteIncidentIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getIncident(incidentId, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getIncident'");
            if (!_config.unstableOperations["v2.getIncident"]) {
                throw new Error("Unstable operation 'getIncident' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "getIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.getIncident").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentRelatedObject>", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getIncidentIntegration(incidentId, integrationMetadataId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getIncidentIntegration'");
            if (!_config.unstableOperations["v2.getIncidentIntegration"]) {
                throw new Error("Unstable operation 'getIncidentIntegration' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "getIncidentIntegration");
            }
            // verify required parameter 'integrationMetadataId' is not null or undefined
            if (integrationMetadataId === null || integrationMetadataId === undefined) {
                throw new baseapi_1.RequiredError("integrationMetadataId", "getIncidentIntegration");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/relationships/integrations/{integration_metadata_id}"
                .replace("{incident_id}", encodeURIComponent(String(incidentId)))
                .replace("{integration_metadata_id}", encodeURIComponent(String(integrationMetadataId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.getIncidentIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listIncidentAttachments(incidentId, include, filterAttachmentType, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listIncidentAttachments'");
            if (!_config.unstableOperations["v2.listIncidentAttachments"]) {
                throw new Error("Unstable operation 'listIncidentAttachments' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "listIncidentAttachments");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/attachments".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.listIncidentAttachments").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentAttachmentRelatedObject>", ""));
            }
            if (filterAttachmentType !== undefined) {
                requestContext.setQueryParam("filter[attachment_type]", ObjectSerializer_1.ObjectSerializer.serialize(filterAttachmentType, "Array<IncidentAttachmentAttachmentType>", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listIncidentIntegrations(incidentId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listIncidentIntegrations'");
            if (!_config.unstableOperations["v2.listIncidentIntegrations"]) {
                throw new Error("Unstable operation 'listIncidentIntegrations' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "listIncidentIntegrations");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/relationships/integrations".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.listIncidentIntegrations").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listIncidents(include, pageSize, pageOffset, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listIncidents'");
            if (!_config.unstableOperations["v2.listIncidents"]) {
                throw new Error("Unstable operation 'listIncidents' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.listIncidents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentRelatedObject>", ""));
            }
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageOffset !== undefined) {
                requestContext.setQueryParam("page[offset]", ObjectSerializer_1.ObjectSerializer.serialize(pageOffset, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchIncidents(query, include, sort, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'searchIncidents'");
            if (!_config.unstableOperations["v2.searchIncidents"]) {
                throw new Error("Unstable operation 'searchIncidents' is disabled");
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new baseapi_1.RequiredError("query", "searchIncidents");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.searchIncidents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "IncidentRelatedObject", ""));
            }
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "IncidentSearchSortOrder", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateIncident(incidentId, body, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'updateIncident'");
            if (!_config.unstableOperations["v2.updateIncident"]) {
                throw new Error("Unstable operation 'updateIncident' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "updateIncident");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.updateIncident").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentRelatedObject>", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateIncidentAttachments(incidentId, body, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'updateIncidentAttachments'");
            if (!_config.unstableOperations["v2.updateIncidentAttachments"]) {
                throw new Error("Unstable operation 'updateIncidentAttachments' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "updateIncidentAttachments");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateIncidentAttachments");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/attachments".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.updateIncidentAttachments").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentAttachmentRelatedObject>", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentAttachmentUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateIncidentIntegration(incidentId, integrationMetadataId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'updateIncidentIntegration'");
            if (!_config.unstableOperations["v2.updateIncidentIntegration"]) {
                throw new Error("Unstable operation 'updateIncidentIntegration' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "updateIncidentIntegration");
            }
            // verify required parameter 'integrationMetadataId' is not null or undefined
            if (integrationMetadataId === null || integrationMetadataId === undefined) {
                throw new baseapi_1.RequiredError("integrationMetadataId", "updateIncidentIntegration");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateIncidentIntegration");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/relationships/integrations/{integration_metadata_id}"
                .replace("{incident_id}", encodeURIComponent(String(incidentId)))
                .replace("{integration_metadata_id}", encodeURIComponent(String(integrationMetadataId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.updateIncidentIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentIntegrationMetadataPatchRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.IncidentsApiRequestFactory = IncidentsApiRequestFactory;
class IncidentsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    createIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createIncidentIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    createIncidentIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteIncidentIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteIncidentIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIncidentIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIncidentIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listIncidentAttachments
     * @throws ApiException if the response code was not in [200, 299]
     */
    listIncidentAttachments(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listIncidentIntegrations
     * @throws ApiException if the response code was not in [200, 299]
     */
    listIncidentIntegrations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listIncidents
     * @throws ApiException if the response code was not in [200, 299]
     */
    listIncidents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchIncidents
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchIncidents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentSearchResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentSearchResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateIncidentAttachments
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateIncidentAttachments(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateIncidentIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateIncidentIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentIntegrationMetadataResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.IncidentsApiResponseProcessor = IncidentsApiResponseProcessor;
class IncidentsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new IncidentsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new IncidentsApiResponseProcessor();
    }
    /**
     * Create an incident.
     * @param param The request object
     */
    createIncident(param, options) {
        const requestContextPromise = this.requestFactory.createIncident(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createIncident(responseContext);
            });
        });
    }
    /**
     * Create an incident integration metadata.
     * @param param The request object
     */
    createIncidentIntegration(param, options) {
        const requestContextPromise = this.requestFactory.createIncidentIntegration(param.incidentId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createIncidentIntegration(responseContext);
            });
        });
    }
    /**
     * Deletes an existing incident from the users organization.
     * @param param The request object
     */
    deleteIncident(param, options) {
        const requestContextPromise = this.requestFactory.deleteIncident(param.incidentId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteIncident(responseContext);
            });
        });
    }
    /**
     * Delete an incident integration metadata.
     * @param param The request object
     */
    deleteIncidentIntegration(param, options) {
        const requestContextPromise = this.requestFactory.deleteIncidentIntegration(param.incidentId, param.integrationMetadataId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteIncidentIntegration(responseContext);
            });
        });
    }
    /**
     * Get the details of an incident by `incident_id`.
     * @param param The request object
     */
    getIncident(param, options) {
        const requestContextPromise = this.requestFactory.getIncident(param.incidentId, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIncident(responseContext);
            });
        });
    }
    /**
     * Get incident integration metadata details.
     * @param param The request object
     */
    getIncidentIntegration(param, options) {
        const requestContextPromise = this.requestFactory.getIncidentIntegration(param.incidentId, param.integrationMetadataId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIncidentIntegration(responseContext);
            });
        });
    }
    /**
     * Get all attachments for a given incident.
     * @param param The request object
     */
    listIncidentAttachments(param, options) {
        const requestContextPromise = this.requestFactory.listIncidentAttachments(param.incidentId, param.include, param.filterAttachmentType, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listIncidentAttachments(responseContext);
            });
        });
    }
    /**
     * Get all integration metadata for an incident.
     * @param param The request object
     */
    listIncidentIntegrations(param, options) {
        const requestContextPromise = this.requestFactory.listIncidentIntegrations(param.incidentId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listIncidentIntegrations(responseContext);
            });
        });
    }
    /**
     * Get all incidents for the user's organization.
     * @param param The request object
     */
    listIncidents(param = {}, options) {
        const requestContextPromise = this.requestFactory.listIncidents(param.include, param.pageSize, param.pageOffset, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listIncidents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listIncidents returning a generator with all the items.
     */
    listIncidentsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listIncidentsWithPagination_1() {
            let pageSize = 10;
            if (param.pageSize !== undefined) {
                pageSize = param.pageSize;
            }
            param.pageSize = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listIncidents(param.include, param.pageSize, param.pageOffset, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listIncidents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                if (param.pageOffset === undefined) {
                    param.pageOffset = pageSize;
                }
                else {
                    param.pageOffset = param.pageOffset + pageSize;
                }
            }
        });
    }
    /**
     * Search for incidents matching a certain query.
     * @param param The request object
     */
    searchIncidents(param, options) {
        const requestContextPromise = this.requestFactory.searchIncidents(param.query, param.include, param.sort, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchIncidents(responseContext);
            });
        });
    }
    /**
     * Updates an incident. Provide only the attributes that should be updated as this request is a partial update.
     * @param param The request object
     */
    updateIncident(param, options) {
        const requestContextPromise = this.requestFactory.updateIncident(param.incidentId, param.body, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateIncident(responseContext);
            });
        });
    }
    /**
     * The bulk update endpoint for creating, updating, and deleting attachments for a given incident.
     * @param param The request object
     */
    updateIncidentAttachments(param, options) {
        const requestContextPromise = this.requestFactory.updateIncidentAttachments(param.incidentId, param.body, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateIncidentAttachments(responseContext);
            });
        });
    }
    /**
     * Update an existing incident integration metadata.
     * @param param The request object
     */
    updateIncidentIntegration(param, options) {
        const requestContextPromise = this.requestFactory.updateIncidentIntegration(param.incidentId, param.integrationMetadataId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateIncidentIntegration(responseContext);
            });
        });
    }
}
exports.IncidentsApi = IncidentsApi;
//# sourceMappingURL=IncidentsApi.js.map